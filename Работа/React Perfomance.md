**Diffing**(дифференциация) - процесс обновления измененного элемента в DOM.

React использует концепцию виртуального DOM, чтобы свести к минимуму затраты производительности на повторный рендеринг веб-страницы, поскольку манипулирование реальным DOM обходится дорого.

Чтобы измерить производительность React приложения используется Profiler из React DevTools. Он записывает, сколько времени требуется компоненту для рендеринга, почему компонент рендерится и многое другое.

## Методы оптимизации производительности React

1. Сохранение локального состояния компонента там, где это необходимо.
	То что у нас обновляется в родительском компоненте стоит вынести в отдельный компонент, чтобы при обновлении состояния обновлялся только он.
2. Запоминание(**мемоизация**) компонентов React для предотвращения ненужного повторного рендеринга.
	В отличие от предыдущего метода повышения производительности, когда рефакторинг нашего кода дает нам прирост производительности, здесь мы обмениваем память на время. Таким образом, мы должны запоминать компонент только тогда, когда это необходимо.

	**Мемоизация** — это стратегия оптимизации, которая кэширует операцию, визуализируемую компонентом, сохраняет результат в памяти и возвращает кэшированный результат для тех же входных данных.

	По сути, если дочерний компонент получает пропсы, мемоизированный компонент поверхностно сравнивает пропсы по умолчанию и пропускает повторный рендеринг дочернего компонента, если они не изменилось.

	####  Использование React.memo()
	
	React.memo() - это HOC используемый для обертывания чисто функционального компонента, чтобы предотвратить повторный рендеринг, если пропсы, полученные в этом компоненте, никогда не меняются.
	
```js
    const ChildComponent = React.memo(function ChildComponent({ count }) { 
        console.log("child component is rendering"); 
        return ( 
            <div> 
                <h2>This is a child component.</h2> 
                <h4>Count: {count}</h4> 
            </div> 
        );
    });
```
	
Если свойство count никогда не меняется, React пропустит рендеринг ChildComponent и повторно использует предыдущий результат рендеринга. Следовательно, улучшение производительности React.

React.memo() работает довольно хорошо, когда мы передаем примитивные значения, такие как число в нашем примере. И, если вы знакомы с ссылочным равенством, примитивные значения всегда ссылочно равны и возвращают true, если значения никогда не меняются.

С другой стороны, непримитивные значения, такие как object, которые включают в себя массивы и функции, всегда возвращают false между повторными рендерингами, потому что они указывают на разные области памяти.
Когда мы передаем объект, массив или функцию в качестве реквизита, мемоизированный компонент всегда перерисовывается.

Чтобы предотвратить постоянное переопределение функции/объекта/массива, можно использовать хук useCallback, который возвращает запомненную версию обратного вызова между рендерингами.

Т.е. мы можем обернуть функцию в useCallback, из-за этого она будет переопределяться только при изменении зависимостей.

Использование **useMemo**

Когда свойство, которое мы передаем дочернему компоненту, представляет собой массив или объект, мы можем использовать хук useMemo для запоминания значения между рендерами. Как мы узнали выше, эти значения указывают на разные области памяти и являются совершенно новыми значениями.

Можно использовать хук useMemo, чтобы избежать повторного вычисления одного и того же дорогостоящего значения в компоненте. Это позволяет нам запоминать эти значения и пересчитывать их только в случае изменения зависимостей.

useMemo так же как и useCallback ожидает функцию и массив зависимостей
	
```js
	const memoizedValue = React.useMemo(() => {
		// return expensive computation 
	}, []);
```

3. **Разделение кода** в React с помощью динамического импорта()
	**Разделение кода** — еще один важный метод оптимизации приложения React. По умолчанию, когда приложение React отображается в браузере, файл «связки», содержащий весь код приложения, загружается и сразу же предоставляется пользователям. Этот файл создается путем слияния всех файлов кода, необходимых для работы веб-приложения.

	Идея объединения полезна, потому что она уменьшает количество HTTP-запросов, которые может обработать страница. Однако по мере роста приложения размеры файлов увеличиваются, что приводит к увеличению файла пакета. В какой-то момент это непрерывное увеличение размера файла замедляет начальную загрузку страницы, снижая удовлетворенность пользователя.

	С разделением кода React позволяет нам разделить большой пакетный файл на несколько фрагментов с помощью динамического импорта () с последующей ленивой загрузкой этих фрагментов по запросу с помощью React.lazy. Эта стратегия значительно повышает производительность страницы сложного приложения React.

	Как было:
	```js
		import Home from "./components/Home"; 
		import About from "./components/About";
	```
	Как стало:
	```js
		const Home = React.lazy(() => import("./components/Home")); 
		const About = React.lazy(() => import("./components/About"));
	```

	Этот синтаксис говорит React динамически загружать каждый компонент. Таким образом, когда пользователь, например, переходит по ссылке на домашнюю страницу, React загружает файл только для запрошенной страницы, а не загружает большой пакетный файл для всего приложения.

	После импорта мы должны визуализировать ленивые компоненты внутри компонента ***Suspense*** следующим образом:

	```js
		<React.Suspense fallback={<p>Loading page...</p>}> 
			<Route path="/" exact> <Home /> </Route> 
			<Route path="/about"> <About /> </Route> 
		</React.Suspense>
	```
	***Suspense*** позволяет отображать загружаемый текст или индикатор в качестве запасного варианта, пока React ожидает отрисовки ленивого компонента в пользовательском интерфейсе.

4. Виртуализация окон или списков в приложениях React
	Если в приложении мы отображаем список, независимо от того, отображаются ли какие-либо элементы в окне просмотра браузера, они отображаются в DOM и могут повлиять на производительность нашего приложения. 

	С концепцией работы с окнами мы можем отображать в DOM только видимую пользователю часть. Затем при прокрутке оставшиеся элементы списка отображаются, заменяя элементы, выходящие из области просмотра. Этот метод может значительно улучшить производительность рендеринга большого списка.

	[react-window](https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/) и [react-virtualized are two popular windowing libraries](https://blog.logrocket.com/windowing-wars-react-virtualized-vs-react-window/) — две популярные оконные библиотеки, которые могут реализовать эту концепцию.

5. Ленивая загрузка изображений в React
	Чтобы оптимизировать приложение, состоящее из нескольких изображений, мы можем не отображать все изображения одновременно, чтобы сократить время загрузки страницы. При ленивой загрузке мы можем подождать, пока каждое из изображений не появится в окне просмотра, прежде чем визуализировать их в DOM.

	Подобно концепции работы с окнами, упомянутой выше, отложенная загрузка изображений предотвращает создание ненужных узлов DOM, повышая производительность нашего приложения React.

	[react-lazyload and react-lazy-load-image-component](https://blog.logrocket.com/the-top-choices-for-react-lazy-loading-libraries-in-2021/) — популярные библиотеки отложенной загрузки, которые можно использовать в проектах React.


	Чтобы успешно оптимизировать наше приложение React, мы должны сначала найти проблему с производительностью в нашем приложении, которую нужно исправить.

	#### Полезны ссылки:

	[React дока](https://ru.reactjs.org/docs/optimizing-performance.html)
	
	[Статья по оптимизации](https://blog.logrocket.com/optimizing-performance-react-application/)
	
	[21 метод оптимизации производительности для приложений React](https://www.codementor.io/blog/react-optimization-5wiwjnf9hj)
	
	 [Статья на habr](https://habr.com/ru/post/495984/)

	[Анализ и оптимизация React-приложений](https://habr.com/ru/company/ruvds/blog/442650/)
