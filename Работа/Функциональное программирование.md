# Функциональное программирование
В функциональном программировании элемент композиции - функция. Передача данных через вызовы функций является композицией

В функциональном программировании не принято менять состояние чего-либо, т.е для обновления какой-либо переменной мы должны сделать следующее:

```js
const a = 2;
const multiply = (oldValue, newValue) => oldValue * newValue;
const newA = multiply(a, 5);
```

Такое неизменяемое состояние называется иммутабельным.

Например, если мы хотим к числу 10 прибавить 5, а потом умножить результат на 2, то последовательно вызовем функции `add` и `multiply`:

```js
function add(a, b) {
  return a + b
}

function multiply(a, b) {
  return a * b
}

const result = multiply(add(10, 5), 2)
```

Чтобы композиция функций была была проще и не вызвала проблем в будущем, эти функции должны быть чистыми.

### Чистая функция

Чистая функция - функция которая принимая в себе одни и те же данные возвращает один и тот же результат, при этом на функцию не действуют никакие side-effects.

### Side-effects

Side-effects - любое взаимодействие с "внешним миром", а именно, использование внешних переменных, обращение к api и тд.

Пример чистой функции: 

```js
const pureFunciton = (a, b) => {
    return a + b;
}
pureFunction(5,5); // 10
```

Пример функции с side-effects (не чистой):

```js
const notPureFunciton = (a,b) => {
    return (a + b) / Math.random();
}
```


### Рекурсия 
В функциональном программировании нельзя менять состояние, следовательно для итерации по чему-либо нельзя использовать обычные циклы. Для этого можно использовать map, reduce или рекурсию.

Рекурсия - это когда функция вызывает сама себя до срабатывания определенного условия, которое ее остановит. 

Примет рекурсии:

```js
const recursiveCounterTo10 = count => {
  if (count === 10) return count;
  return recursiveCounterTo10(count + 1);
};

recursiveCounterTo10(1); // 10
```


### Функции высшего порядка

Функции высшего порядка - функции которые могут принимать и возвращать другие функции, например: map, filter, reduce и тд.

Пример:

```js
const multiply2 = a => a * 2;
const sum2 = a => a + 2;

const hof = (number, action) => action(number);

hof(3,multiply2); // 6
hof(3, sum2); // 5
```

### Каррирование

Каррирование - трансформация функции таким образом, чтобы она могла принимать аргументы разными способами: `func(a,b)` или `func(a)(b)`.

Пример каррирования:

```js
const curryingSum = (a, b) => {
  if (b !== undefined) {
    return a + b;
  }
  return b => {
    return a + b;
  };
};
curryingSum(1, 2); // 3
curryingSum(1)(2); // 3
```

### Паттерн-матчинг

Концепция в которой значение сопоставляется с другими, заранее подготовленными, если что-то совпадает, то выполняются какие-то действия, схож с `switch`


# Плюсы функционального программирования

## Надежность и удобство тестирования
Чистые функции надежны, ведь если туда приходят одинаковые значения,  то и результат будет одинаковый
Так же их удобно тестировать

## Оптимизация при компиляции
При компиляции кода можно выполнить некоторые куски кода заранее, что приведет к меньшим затратам на ресурсы

## Параллелизм и потокобезопасность 
Функциональное программирование запрещает менять состояния, что огораживает нас от случая, когда в одну переменную пытаются записать значение две разных функции


# Минусы функционального программирования

## Повышенное потребление памяти
Т.к в функциональном программировании мы не можем напрямую изменять состояние, нам приходится создавать его полную копию

## Сложность работы с "внешним миром"
Весь "внешний мир" состоит из побочных эффектов, что не приветствуется в функциональном программировании. Для решения этой проблемы можно:

- Получить значение из функции с side-effects
- Передать это значение в чистую функцию и вернуть результат
- Еще каким-либо образом взаимодействовать с результатом в другой функции с side-effects



Полезно ознакомиться с [парадигмами программирования](https://doka.guide/js/programming-paradigms/)
# Ресурс
[Дока](https://doka.guide/js/fp/#plyusy-funkcionalnogo-programmirovaniya)
