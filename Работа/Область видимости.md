# Область видимости и виды поиска

**Область видимости** - это набор правил поиска переменных по их идентификатору.

Существует 2 поиска которые использует движок жс: 
**LHS** - Left Hand Side
**RHS** - Right Hand Side

**LHS**-поиск выполняется, когда переменная появляется с левой стороны операции присваивания, а **RHS**-поиск выполняется, когда переменная появляется с правой стороны операции присваивания.

```js
var a = 2;
```

- Сначала идет проверка на существование этой переменной, если существует, то компилятор пропускает это объявление, если нет, то создается новая переменная в укзанной области видимости.
- После компилятор сгенерирует код, чтобы присвоить значение переменной. Для этого сначала будет проверка, что объявленная переменная доступна в области видимости, если есть, то происходит присвоение, иначе компилятор ищет эту переменную в другом месте, если не находится, то выкидавает ошибку.

# Лексическая область видимости

**Лексическая область видимости** - область видимости которая существует при разбиении команды на лексемы. Другими словами это где переменные и блоки видимости были созданы во время разработки.

**Лексическая область видимости** - набор правил как движок жс будет искать переменную и как может ее найти.

# Поднятие (hoisting)

**Поднятие** - механизм когда впервую очередь будет обработано объявление переменной/функции в следствии чего она поднимется вверх, а присвоение какого-либо значения будет выполнятся своевременно (там где было изначально)

```js
console.log(a); // undefined
var a = 2;
```

Как это интерпретирует жс:
```js
var a;
console.log(a); // undefined
a = 2;
```

Поднятие переменной/функции зависит от как она была объявлена:

- Если переменная объявлена через var, поднятие будет работать как на примере выше
- Если переменная объявлена через let или const, то при попытке поднятия переменной будет выброшенна ошибка  ReferenceError

  ```js
    console.log(a); // ReferenceError: cannot access "a" before initialization
	let a = 2;
   ```
   Все потому что var имеет глобаную область видимости, а let и const блочную.
- Если функция объявлена через ключевое слово  function, поднятие будет работать тем же образом что и с переменными объявленными через ключевое слово var. тоже имеет глобальную область видимости
- Если функция объявлена через присвоение переменной, то поднятие будет работать следующим образом:
  используя let/const
  
  ```js
	  console.log(a()) // TypeError: a is not a function
	  console.log(a) // ReferenceError: cannot access "a" before initialization
	  let a = () => {
		  console.log(2);
	  }
   ```
   Если обявлять функция через var, то произойдет поднятие и и создастся переменная:
   
   ```js
	   console.log(a()) // TypeError: a is not a function
	   console.log(a) // undefined
	   var a = () => {
		   console.log(2);
		}
    ```

# Замыкание

**Замыкание** — это когда функция умеет запоминать и имеет доступ к лексической области видимости даже тогда, когда эта функция выполняется вне своей лексической области видимости.

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a );
	}

	return bar;
}

var baz = foo();

baz(); // 2
```

Функция **bar** является замыканием, она имеет доступ к лексической области видимости функции **foo**, следовательно имеет доступ к переменной **a**.
При присовении **foo** в переменную **baz** происходит следующее:
- значение **baz** становится равным объекту функии **bar**
  
  ```js
	 console.log(baz) // function bar() { console.log( a ); }
   ```
- когда мы вызываем **baz** как функцию, то мы получаем доступ к лексической области видимости функции **foo**, как и было с функцией **bar**
- следовательно мы имеем доступ к переменной **a**, так как это область видимости сохранилась (потому что у **bar** есть замыкание на эту область видимости и она до сих пор используется)

# Еще немного об области видимости

Существует так же **динамическая** область видимости.

**Динамическая** область видимости определяется при выполнении кода

**Лексическую** область видимости интересует _где функция была объявлена_, а **динамическую** — _откуда была вызвана_ функция.